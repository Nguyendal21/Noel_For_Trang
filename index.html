<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Interactive Christmas Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205; /* N·ªÅn t·ªëi h∆°n ƒë·ªÉ l√†m n·ªïi b·∫≠t ƒë√®n */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
            /* T·∫°o hi·ªáu ·ª©ng n·ªÅn tr·ªùi ƒë√™m nh·∫π */
            background: radial-gradient(circle at center, #111 0%, #020205 100%);
        }

        /* UI Control Panel */
        #ui-panel {
            position: absolute;
            top: 20px; left: 20px; z-index: 10;
            background: rgba(0, 0, 0, 0.5); /* T·ªëi h∆°n v√† trong su·ªët h∆°n */
            backdrop-filter: blur(8px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            width: 200px;
        }

        h2 { margin: 0 0 10px 0; font-size: 16px; text-transform: uppercase; color: #ffdf00; } /* M√†u v√†ng kim */

        /* Webcam preview (flipped) */
        #webcam-preview {
            position: absolute; bottom: 20px; right: 20px;
            width: 120px; height: 90px; /* Nh·ªè h∆°n m·ªôt ch√∫t */
            border-radius: 8px;
            border: 2px solid rgba(255,215,0,0.3); /* Vi·ªÅn v√†ng nh·∫°t */
            z-index: 10;
            transform: scaleX(-1);
            object-fit: cover;
            background: #000;
            opacity: 0.7; /* L√†m m·ªù webcam ƒëi m·ªôt ch√∫t ƒë·ªÉ ƒë·ª° ph√¢n t√¢m */
            transition: opacity 0.3s;
        }
        #webcam-preview:hover { opacity: 1; }

        #status { font-size: 13px; font-weight: bold; margin-top: 5px; }
        
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020205; color: #ffdf00;
            display: flex; justify-content: center; align-items: center; font-size: 20px;
            z-index: 999; transition: opacity 0.8s ease-out;
        }
    </style>
</head>
<body>

    <div id="loading" class="loading-overlay">
        <div>üéÑ ƒêang chu·∫©n b·ªã c√¢y th√¥ng Noel... üéÑ</div>
    </div>

    <div id="ui-panel">
        <h2>T∆∞∆°ng T√°c C√¢y Th√¥ng</h2>
        <div id="status" style="color: #aaa;">ƒêang ƒë·ª£i camera...</div>
        <div style="font-size: 11px; margin-top:15px; color:#ccc; line-height: 1.4;">
            S·ª≠ d·ª•ng <b>2 tay</b> tr∆∞·ªõc camera:<br>
            ‚ÜîÔ∏è K√©o ra xa: C√¢y "bung" ra.<br>
            ‚û°Ô∏è‚¨ÖÔ∏è ƒê∆∞a l·∫°i g·∫ßn: C√¢y thu l·∫°i.
        </div>
    </div>

    <video id="webcam-preview" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 1. CONFIGURATION & STATE ---
        const PARTICLE_COUNT = 5000; // TƒÉng s·ªë l∆∞·ª£ng h·∫°t cho c√¢y d√†y h∆°n
        const TREE_HEIGHT = 60;
        const TREE_BASE_RADIUS = 25;
        
        let expansionFactor = 1.0;
        let targetExpansion = 1.0;
        let particlesMesh;
        // Store original position AND its distance from center (radius) for expansion math
        let originalData = []; 
        
        // --- 2. THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Fog nh·∫π m√†u t·ªëi ƒë·ªÉ t·∫°o chi·ªÅu s√¢u
        scene.fog = new THREE.FogExp2(0x020205, 0.003);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Di chuy·ªÉn camera ra xa v√† l√™n cao m·ªôt ch√∫t ƒë·ªÉ nh√¨n to√†n c·∫£nh c√¢y
        camera.position.set(0, 10, 120);
        camera.lookAt(0, 5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // --- 3. CREATE CHRISTMAS TREE PARTICLES ---
        function createTexture() {
            // Texture ƒë·ªëm s√°ng m·ªÅm (gi·ªëng ƒë√®n led)
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,255,255,0.6)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.Texture(canvas);
        }

        function initParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            const texture = createTexture();
            texture.needsUpdate = true;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // --- T·∫†O H√åNH D√ÅNG C√ÇY TH√îNG ---
                // percentUp: 0 l√† ƒë√°y, 1 l√† ƒë·ªânh. 
                // D√πng Math.pow ƒë·ªÉ t·∫≠p trung nhi·ªÅu h·∫°t h∆°n ·ªü ph·∫ßn d∆∞·ªõi (t√°n c√¢y d√†y h∆°n ·ªü g·ªëc)
                const percentUp = Math.pow(Math.random(), 1.2); 
                
                // T√≠nh to√°n v·ªã tr√≠ Y (chi·ªÅu cao)
                // ƒê·∫∑t g·ªëc c√¢y th·∫•p h∆°n tr·ª•c trung t√¢m m·ªôt ch√∫t
                const y = (percentUp * TREE_HEIGHT) - (TREE_HEIGHT * 0.4);

                // B√°n k√≠nh t·ªëi ƒëa t·∫°i ƒë·ªô cao n√†y (c√†ng l√™n cao c√†ng nh·ªè)
                // (1 - percentUp) s·∫Ω gi·∫£m t·ª´ 1 v·ªÅ 0 khi l√™n ƒë·ªânh
                const maxRadiusAtHeight = TREE_BASE_RADIUS * (1 - percentUp);

                // T·∫°o v·ªã tr√≠ ng·∫´u nhi√™n trong h√¨nh tr√≤n b√°n k√≠nh maxRadiusAtHeight
                // D√πng sqrt(random) ƒë·ªÉ ph√¢n b·ªë ƒë·ªÅu trong h√¨nh tr√≤n
                const r = maxRadiusAtHeight * Math.sqrt(Math.random()) * 1.1; // Nh√¢n nh·∫π 1.1 ƒë·ªÉ c√¢y tr√¥ng x·ªëp h∆°n
                const theta = Math.random() * Math.PI * 2; // G√≥c ng·∫´u nhi√™n

                const x = r * Math.cos(theta);
                const z = r * Math.sin(theta);

                positions.push(x, y, z);
                
                // L∆∞u d·ªØ li·ªáu g·ªëc ƒë·ªÉ t√≠nh to√°n m·ªü r·ªông sau n√†y
                // Ch√∫ng ta c·∫ßn vector chu·∫©n h√≥a t·ª´ t√¢m ƒë·ªÉ bi·∫øt h∆∞·ªõng "n·ªï"
                const distance = Math.sqrt(x*x + y*y + z*z) || 1; // avoid div by zero
                originalData.push({
                    x: x, y: y, z: z,
                    normX: x/distance, normY: y/distance, normZ: z/distance,
                    dist: distance
                });

                // --- T·∫†O M√ÄU S·∫ÆC RGB ƒêA D·∫†NG (FESTIVE COLORS) ---
                const randColorType = Math.random();
                let rCol, gCol, bCol;

                if (randColorType < 0.65) { 
                    // 65% l√† m√†u Xanh l√° c√¢y (th√¢n l√°) v·ªõi bi·∫øn th·ªÉ nh·∫π
                    rCol = 0.1 + Math.random() * 0.2;
                    gCol = 0.5 + Math.random() * 0.5; // Xanh t∆∞∆°i
                    bCol = 0.1 + Math.random() * 0.2;
                } else if (randColorType < 0.80) {
                    // 15% l√† ƒê·ªè (qu·∫£ ch√¢u)
                    rCol = 0.8 + Math.random() * 0.2;
                    gCol = Math.random() * 0.2;
                    bCol = Math.random() * 0.2;
                } else if (randColorType < 0.92) {
                     // 12% l√† V√†ng kim (ƒë√®n/d√¢y kim tuy·∫øn)
                    rCol = 0.9 + Math.random() * 0.1;
                    gCol = 0.8 + Math.random() * 0.2;
                    bCol = Math.random() * 0.2;
                } else {
                    // 8% l√† Xanh d∆∞∆°ng/Tr·∫Øng (ƒë√®n nh√°y l·∫°nh)
                    rCol = 0.2 + Math.random() * 0.8;
                    gCol = 0.2 + Math.random() * 0.8;
                    bCol = 1.0;
                }
                colors.push(rCol, gCol, bCol);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            // QUAN TR·ªåNG: Th√™m thu·ªôc t√≠nh m√†u cho vertex
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2.5, // K√≠ch th∆∞·ªõc h·∫°t l·ªõn h∆°n ƒë·ªÉ r√µ m√†u
                map: texture,
                vertexColors: true, // K√çCH HO·∫†T M√ÄU ƒêA D·∫†NG
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending, // Pha tr·ªôn ki·ªÉu √°nh s√°ng
                depthWrite: false // Gi√∫p c√°c h·∫°t trong su·ªët ch·ªìng l√™n nhau ƒë·∫πp h∆°n
            });

            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }

        initParticles();

        // --- 4. MEDIAPIPE HAND TRACKING (Gi·ªØ nguy√™n logic c≈©) ---
        const videoElement = document.getElementById('webcam-preview');
        const statusElement = document.getElementById('status');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                statusElement.innerText = "üéÑ ƒê√£ nh·∫≠n 2 tay!";
                statusElement.style.color = "#00ff00";

                const hand1 = results.multiHandLandmarks[0][9]; 
                const hand2 = results.multiHandLandmarks[1][9];
                const dx = hand1.x - hand2.x;
                const dy = hand1.y - hand2.y;
                const distance = Math.sqrt(dx*dx + dy*dy);

                // Map distance to expansion (tuned for better feel)
                const minD = 0.15; const maxD = 0.7;
                const minS = 1.0;  const maxS = 5.5;
                const clampedDist = Math.max(minD, Math.min(maxD, distance));
                const percent = (clampedDist - minD) / (maxD - minD);
                targetExpansion = minS + (percent * (maxS - minS));

            } else {
                statusElement.innerText = results.multiHandLandmarks.length === 1 ? "C·∫ßn th√™m 1 tay..." : "ƒêang t√¨m tay...";
                statusElement.style.color = results.multiHandLandmarks.length === 1 ? "orange" : "#aaa";
                targetExpansion = 1.0; // Reset v·ªÅ tr·∫°ng th√°i c√¢y b√¨nh th∆∞·ªùng
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });

        cameraUtils.start().then(() => {
            const loader = document.getElementById('loading');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 850);
        }).catch(err => alert("L·ªói Camera: " + err));


        // --- 5. ANIMATION LOOP ---
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Hi·ªáu ·ª©ng n·ªôi suy m∆∞·ª£t m√† cho vi·ªác m·ªü r·ªông/thu nh·ªè
            expansionFactor += (targetExpansion - expansionFactor) * 0.1;

            const positions = particlesMesh.geometry.attributes.position.array;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const data = originalData[i];
                const i3 = i * 3;

                // --- LOGIC CHUY·ªÇN ƒê·ªòNG M·ªöI ---
                // Khi ·ªü tr·∫°ng th√°i c√¢y (expansionFactor g·∫ßn 1), ch√∫ng ta mu·ªën n√≥ gi·ªØ h√¨nh d·∫°ng c√¢y.
                // Khi m·ªü r·ªông, ch√∫ng ta mu·ªën n√≥ bay ra t·ª´ t√¢m theo h∆∞·ªõng c·ªßa n√≥.

                // 1. V·ªã tr√≠ c∆° b·∫£n c·ªßa c√¢y (rung rinh nh·∫π ƒë·ªÉ t·∫°o s·ª± s·ªëng ƒë·ªông)
                // Rung rinh nhi·ªÅu h∆°n ·ªü ph·∫ßn l√° (m√†u xanh) v√† √≠t h∆°n ·ªü ph·∫ßn ƒë√®n
                const isLeaf = particlesMesh.geometry.attributes.color.array[i3+1] > 0.4; // Check k√™nh Green
                const windForce = isLeaf ? 0.8 : 0.3;
                
                const treeX = data.x + Math.cos(time + data.y * 0.1) * windForce;
                const treeY = data.y + Math.sin(time * 1.5 + data.x * 0.1) * (windForce * 0.5);
                const treeZ = data.z;

                // 2. V·ªã tr√≠ khi n·ªï (bay ra xa kh·ªèi t√¢m)
                // S·ª≠ d·ª•ng vector chu·∫©n h√≥a (normX, normY, normZ) * kho·∫£ng c√°ch * h·ªá s·ªë m·ªü r·ªông
                // Th√™m m·ªôt ch√∫t nhi·ªÖu (noise) khi n·ªï ƒë·ªÉ tr√¥ng h·ªón lo·∫°n h∆°n
                const explosionNoise = 1 + (Math.random()-0.5) * 0.2 * (expansionFactor - 1);
                const explodedDist = data.dist * expansionFactor * explosionNoise;
                
                const explodedX = data.normX * explodedDist;
                const explodedY = data.normY * explodedDist;
                const explodedZ = data.normZ * explodedDist;

                // 3. Pha tr·ªôn gi·ªØa hai tr·∫°ng th√°i d·ª±a tr√™n expansionFactor
                // N·∫øu expansionFactor l√† 1 -> d√πng treePos. N·∫øu l·ªõn h∆°n -> blend sang explodedPos.
                // S·ª≠ d·ª•ng m·ªôt h√†m smoothstep ho·∫∑c t∆∞∆°ng t·ª± ƒë·ªÉ chuy·ªÉn ƒë·ªïi m∆∞·ª£t m√† h∆°n
                let blendRatio = Math.max(0, expansionFactor - 1.0); // 0 t·∫°i tr·∫°ng th√°i c√¢y, tƒÉng d·∫ßn khi m·ªü r·ªông
                blendRatio = Math.min(1, blendRatio / 2.0); // Chu·∫©n h√≥a ƒë·ªÉ blendRatio max l√† 1 khi expansionFactor kho·∫£ng 3

                // N·ªôi suy tuy·∫øn t√≠nh (Lerp) gi·ªØa v·ªã tr√≠ c√¢y v√† v·ªã tr√≠ n·ªï
                positions[i3]     = treeX + (explodedX - treeX) * blendRatio;
                positions[i3 + 1] = treeY + (explodedY - treeY) * blendRatio;
                positions[i3 + 2] = treeZ + (explodedZ - treeZ) * blendRatio;
            }

            particlesMesh.geometry.attributes.position.needsUpdate = true;

            // Xoay nh·∫π to√†n b·ªô c√¢y ƒë·ªÉ xem 3D
            particlesMesh.rotation.y = Math.sin(time * 0.2) * 0.15; 

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
